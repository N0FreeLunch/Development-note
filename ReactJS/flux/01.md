# Flux

### 리액트의 특징
- 리액트는 상위 컴포넌트와 하위 컴포넌트의 트리 구조로 구성되어 있으며, 최상단에 하나의 컴포넌트로 부터 하위 컴포넌트를 포함하는 방식으로 구성된다.
- 리액트는 데이터를 각 로컬 스테이트로 관리를 하거나, 상위 컴포넌트의 데이터를 하위 컴포넌트에게 전달하는 방식으로 구성한다. 
- 상위 컴포넌트에 공통적으로 데이터를 저장할 수도 있지만 컴포넌트가 분기 되기 시작하기 전의 최상위 계층의 컴포넌트에 데이터를 항상 저장하는 것이 아닌 상위 컴포넌트에 데이터를 저장하고 공유가 필요한 데이터는 하위 컴포넌트에서 상위 컴포넌트의 상태를 공유하는 방식으로 사용한다.


### MVC 패턴
- 모델, 뷰, 컨트롤러로 구성
- 모델 : 데이터가 들어 있는 집합에서 일부 데이터를 추출, 수정, 삭제등을 하기 위한 기능을 만들어 둔 것
- 뷰 : 유저 인터페이스를 담당하는 부분으로 유저에게 데이터 집합에서 모델을 통해 꺼낸 데이터를 보여 주고 데이터 집합의 데이터를 지우거나 수정하는 유저의 조작을 받는 부분
- 컨트롤러 : 모델과 뷰 사이의 데이터 전달에 관여하여 모델과 뷰 사이의 데이터를 적절한 형태로 가공하여 전달이 이뤄질 수 있도록 하는 부분

### 리액트에서의 MVC 패턴

#### MVC 패턴의 뷰는 여러 모델에 따라 업데이트 된다
- 상위 컴포넌트와 하위 컴포넌트의 관계에서 상위 컴포넌트의 스테이트 변경 이벤트는 하위 컴포넌트를 랜더링하게 한다.
- 이것을 MVC 패턴으로 보면 상위 컴포넌트의 상태는 Model이며, 이 상위 컴포넌트에 영향을 받는 하위 컴포넌트는 상위 컴포넌트의 모델에 대해 뷰를 생성한다.
- 하나의 컴포넌트에 대해서 상위 컴포넌트는 여러개가 있을 수 있으며 이 여러개는 상위 하위 관계로 구성되어 있다. 이는 하나의 컴포넌트의 랜더링은 여러 상위 컴포넌트에 영향을 받는는 뜻이다. 
- MVC 관점에서는 하나의 뷰는 여러 상위 컴포넌트의 모델에 따라 업데이트가 된다. 

#### MVC 패턴의 뷰는 여러 모델에 영향을 끼침
- 하위 컴포넌트는 상위 컴포넌트로 부터 상위 컴포넌트의 상태를 변경할 수 있는 함수를 전달 받을 수 있다.
- 유저의 조작이나 컴포넌트 내부에 정의한 어떤 상태 변화를 유도하는 무언가에 의해서 상위 컴포넌트에서 전달 받은 상태 변경 메서드를 통해 상위 컴포넌트의 상태를 바꿀 수 있다. 
- 하나의 컴포넌트에 대한 상위 컴포넌트는 여럿이기 때문에 이는 MVC 패턴에 따라 보면 하위 컴포넌트에서 상위 컴포넌트의 상태변경을 유도하는 어떤 이벤트 (자바스크립트의 이벤트가 아닌 개념적인 이벤트)에 의해 상위 컴포넌트의 모델의 데이터를 변경하게 된다. 

### MVC의 문제
#### MVC의 특성
- 여러 모델은 하나의 뷰를 업데이트 시킬 수 있다.
- 뷰는 여러 모델에 영향을 끼칠 수 있다.

#### MVC의 문제 이유
> a 컴포넌트는 A라는 상위 컴포넌트의 하위 컴포넌트이며 A와 a는 여러 개의 컴포넌트 계층으로 구성되어 있다.
> b 컴포넌트는 B라는 상위 컴포넌트의 하위 컴포넌트이며 B와 b는 여러 개의 컴포넌트 계층으로 구성되어 있다.
> A 와 B는 공통의 상위 컴포넌트 S를 가지고 있다.
> a 컴포넌트에는 메시지의 읽지 않은 수를 표시한다.
> b 컴포넌트에는 읽지 않는 메시지를 강조하는 목록을 표시한다. 
> b 컴포넌트의 메시지를 하나 읽게 되면, a 컴포넌트의 카운터가 1 감소해야 한다.
- b는 S의 상태를 변경해야 한다. S의 상태를 변경하게 되면S는 a를 랜더링 시키기 위해서 S와 a사이의 모든 컴포넌트를 랜더링 시킨다.
- 계단식 업데이트
- 종속성
- 데이터 흐름이 뒤엉켜 예측 불가



### Flux 패턴이란?
- 데이터를 한 방향으로 흐르게 하기 위한 패턴
- MVC 패턴과는 다른 또 하나의 패턴이다.
- MVC가 모델, 뷰, 컨트롤러의 구성인 것에 반해 Flux는 엑션, 디스패처, 스토어, 뷰로 구성되어 있다.
- 리액트는 컴포넌트가 분기 되기 시작하기 전의 최상위 계층의 컴포넌트에 변수를 저장하여 전역 변수 처럼 사용할 수 있다.



### 뷰
- 뷰는 유저에게 보여지는 영역이다. 웹 어플리케이션에서 MVC의 뷰(view)는 화면에 보이는 영역으로 유저 인터페이스를 담당하는 영역이다. 리액트 어플리케이션 한정으로 보면 화면에 랜더링을 담당하는 부분이다.
- 뷰는 리액트의 컴포넌트를 의미하는 것이 아니며 JSX 또는 createElement로 전달받은 데이터가 합쳐져 불변 객체인 React-element로 변환되는 과정을 담당하는 기능 및 React-element가 화면에 랜더링 되는 부분까지를 의미한다. 컴포넌트는 이미 적재되어 있는 상태이며 이 컴포넌트는 자바스크립트에 의해 실행 컨텍스트화 되어 있는 상태이다. 뷰는 실행 컨텍스트 상태에서 React-element를 만들고 랜더링을 하여 화면에 보여주는 역할까지를 의미한다. React-element가 Dom-element가 되는 과정은 정해져 있는 로직을 따르므로 통상적으로 뷰는 React-element를 만드는 과정까지라고 볼 수도 있다.
- 뷰가 스토어로 부터 이벤트를 전달 받으면, 뷰는 스토어에 내장된 getter 메서드를 호출하여 스토어에 저장된 새로운 데이터를 가져온다. 데이터를 가져오게 되면 setState() 또는 forceUpdate() 메서드를 호출 하여 컴포넌트의 render() 메서드와 모든 하위 뷰의 render() 함수를 호출한다. 하위 뷰를 랜더링 하는 방식은 데이터 전달을 통해 리액트 컴포넌트의 갱신 사이클을 돌리는 것이다.
- React flux 패턴에서 뷰는 계층적 컴포넌트에 의해 생성되는 실행 컨텍스트 상에서의 계층적 뷰이며, 뷰 계층의 최상위의 스토어에서 생성된 브로드캐스팅 이벤트를 전달받고 스토어에서 데이터를 얻어 불변 객체인 React-element로 변환된다.
- 스토어의 이벤트를 받은 뷰는 스토어에서 데이터를 가져오고 하위 뷰로 가져온 데이터를 전달 할 수 있다. 이를 체인이라고 한다.



### 컨트롤러
- 뷰와 모델 사이에서 데이터 전달을 컨트롤 하는 부분을 의미한다.
- 리액트에서는 컴포넌트에 저장되어 있는 상태(state)가 setState에 의해 상태 변경 이벤트가 발생하면 변경되는 상태들을 종합해서 상태 변경이 이뤄진 뷰의 render()를 호출함과 동시에 하위 뷰에 상태 데이터를 전달하고 전달된 데이터를 반영하여 하위 뷰들도 render() 함수를 호출한다. 이렇게 저장된 상태를 뷰로 전달하는 매커니즘에 관한 부분을 리액트에서 컨트롤러라고 한다.
- 체인을 통해 상태 데이터가 뷰로 전달되는 부분에서 전달되는 데이터를 가공해서 전달하는 것이 개발자가 리액트에서 다룰 수 있는 컨트롤러의 영역이다.
- flux 패턴에서는 저장소가 뷰 계층의 탑(최상단) 끝점에 있고 여기서 데이터를 뷰로 전달한다. 저장소에서 뷰로 데이터를 전달 할 수 있는 부분이 최상단 뷰이다. '저장소 => 최상단 뷰'로 데이터가 전달되며 이 부분이 컨트롤러의 영역이다. 하위 뷰로 데이터가 전달되는 과정은 뷰의 내부 매커니즘으로 봐야 하므로 컨트롤러라고 할 수 있는 부분이 아주 작다. 그리고 리액트의 flux 패턴에서 이 부분에 대한 컨트롤을 커스텀으로 추가하지 않는다. 



### 컨트롤러-뷰



### 스토어
- 플럭스 모델에서는 스토어는 모델에 대응한다.
- 웹 어플리케이션의 MVC에서 모델은 데이터베이스 전체 데이터가 아닌 디비의 일부 데이터만 가져와서 데이터를 집어 넣고 수정하고 삭제한다. 이는 모델의 뜻이 데이터를 조회, 삽입, 수정, 삭제하기 위한 어떤 코드, 구조, 기능을 의미하는 것으로 볼 수 있다.
- 웹 어플리케이션의 모델과는 달리 flux 패턴에서의 store는 리액트 어플리케이션의 렌더링에 필요한 모든 상태를 담고 있기 때문에 모델이라기 보다는 스토어라고 부른다. 마치 웹 어플리케이션의 MVC 모델의 데이터베이스처럼 모든 상태데이터를 저장하는 곳이 스토어이다. 하지만 스토어는 특정 도메인에 대한 정보를 저장하는 곳으로 정의된다. 스토어는 단일하지 않으며 도메인 별로 스토어가 하나씩 존재할 수 있으며 각 스토어는 각 도메인을 랜더링 하기 위한 모든 상태를 담고 있다.
- 저장소라는 뜻은 응용프로그램 내의 특정 도메인의 상태를 저장하는 의미를 가지고 있으며 flux 패턴에서는 리액트로 구성된 프론트앤드 어플리케이션에서 브라우저에서 화면을 랜더링하는 도메인에 대한 상태 데이터를 저장하는 의미를 갖는다.
- 페이스북의 예 : Lookback Video Editor에서 재생 시간에 관한 상태를 저장하는 곳으로 TimeStore라는 저장소를 사용했다. TimeStore를 통해서  재생 시간 위치와 재생 상태를 추적할 수 있다. 이미지 모음에서는 ImageStore라는 저장소를 사용하여 그룹단위로 저장된 이미지를 추적할 수 있다. 이는 재생 시간에 관한 도메인과 이미지에 관한 도메인에 대한 저장소를 각각 구성한 것이다. 또한 TodoMVC예제에서 To do list의 각각의 항목에 대한 상태를 저장하는 곳이 TodoStore로 어플리케이션의 특정 도메인(재생시간, 이미지, 할 일)에 대한 상태를 저장하는 곳이 저장소라는 개념의 핵심이다.
- 스토어는 뷰의 전체 상태를 관리하기 때문에 스토어에서 여러 대상이 되는 뷰로 이벤트를 보내는 과정을 브로드캐스팅이라고 한다. 
- flux 패턴에서 유일하게 Mutable, 곧 상태가 변경되는 곳이다. 플럭스 패턴은 엑션, 디스패처, 스토어로 구성되어 있으므로 엑션과 디스패처는 stateless, Immutable의 특성을 가진다.



### 엑션 (Action)
- 유저의 입력을 디스패치에 전달하기 위한 코드이다. 
- 디스페처를 통해 구현된 큐에 엑션을 넣고 큐에 넣어진 순서대로 엑션이 스토어에 전달된다.



### 디스패처
- 엑션을 큐에 넣고 큐에 넣어진 순서대로 빼 내어 적절한 도메인의 스토어에 집어 넣는 역할 을 한다.
- 스토어에 내장되어 있으며, storeDomianName.dispatch() 방식으로 사용한다.
- Flux 패턴에서 디스패처는 하나만 존재한다. 이를 단일 디스패처(A single dispatcher)라고 부른다.
- 하나의 디스패처는 엑션을 통해 여러 도메인의 스토어로 데이터를 전달한다.



### 단일 디스패처 (A Single Dispatcher)
- Flux 애플리케이션의 모든 데이터 흐름을 관리하는 중앙 허브 역할을 하며 Flux 패턴에서 디스패처는 하나만 존재한다.
- 마법과 같은 기능을 제공하는 것은 아닌 사용자가 정의 한 대로 쓴다.
- 스토어에 엑션을 걸어주기 위해 쓰는 단순한 매커니즘
- 각 스토어는 레지스터가 있고 콜벡을 제공한다.
- action 생성자가 디스패처에 새로운 action을 전달하면 리액트 어플리케이션의 모든 저장소가 디스패처의 콜백에 등록된 작업을 통해 데이터를 등록한다.
- 스토어의 의존성을 관리하기 위해서 특정한 순서에 따라 등록된 콜백을 호출한다. 
- 스토어는 다른 스토어를 선언적으로 기다리며 업데이트를 끝낸다. 이 작업이 완료되면 그 자체를 업데이트 한다.
- 리액트 어플리케이션의 모든 데이터를 통합 관리하는 한 단위의 저장소를 중앙 디스패처라고 한다. Flux 모델에서는 디스패처가 하나이므로 central dispatcher = a single dispatcher 라고 할 수 있다.
- 디스패처를 통해 스토어의 상태가 변하면 영향을 받는 모든 컴포넌트는 새로 랜더링(업데이트)을 하게 된다.




### React flux 패턴에서 저장소 구현
- 저장소는 디스패처에 등록이 되며, 디스패처는 저장소를 업데이트 할 수 있는 기능을 정의할 수 있는 콜백을 제공한다. 콜백 함수 내에 저장소를 업데이트 하는 기능을 구현하면 된다.
- 추가적인 내용 필요.


### Flux 패턴의 특징
- 기존의 리액트는 많은 수의 props를 하위 컴포넌트에 전달하는 방식으로 구성되어 있는 것에 반해 Flux 패턴은 스토어에서 상태 집합인 단일 객체를 뷰에 넘기므로 많은 수의 props를 넘기는 로직을 만들 필요가 없다. props의 수를 줄이는 대신 dispatch를 사용하여 스토어에 상태를 저장하는 로직이 추가된다.
- Mutable인 store에서 데이터를 최상단 뷰로 전달하면 뷰는 전달받은 단일 객체 상태 집합을 사용해서 자체적으로 랜더링을 한다. 이 때 뷰라는 것은 정의역에 스토어로 부터 받은 단일 객체를 원소로 받고 React-element를 리턴하는 함수이다. 곧 불변 객체인 React-element와 single object from store의 관계는 React-element = view(single object from store)의 공식을 가지는 함수라고 할 수 있다. 이 패턴을 통해 view는 순수 함수형의 특징을 가진다.



### Flux 패턴에 모델, 컨트롤러가 없는 이유
- 앤터티란 저장소에 저장될 수 있는 어떤 것이다. 모델이라는 것은 전체 상태의 집합에서 일부 앤터티에 대한 앤터티의 상태를 변경하는 매커니즘들의 집합을 의미한다. 그런데 flux 패턴에서는 일부 앤터티에 대한 상태를 변경하게 되면 ... 뷰에 데이터를 전달할 때 일부 엔터티를 가져 오는 것이 아닌 저장소의 모든 상태를 뷰들로 전달하는 방식이기 때문에 일부 엔터티 데이터들을 뷰에 전달하는 역할을 하는 컨트롤러와는 개념이 다르다.???
- Flux 패턴에서는 스토어의 전체 데이터를 객체화 하여 뷰 계층의 탑에서 데이터를 하위 뷰로 체인하여 전달하는 방식이다. 모든 상태를 뷰 전체에 전달하는 방식이기 때문에 ...



### flux update cycle







# Flux


### Flux란?
- 데이터를 한 방향으로 흐르게 하기 위한 패턴


### MVC 패턴
- 모델, 뷰, 컨트롤러로 구성
- flux는 MVC 모델과는 다르다!!!

#### 뷰는 여러 모델에 따라 업데이트 된다
- 상위 컴포넌트와 하위 컴포넌트의 관계에서 상위 컴포넌트의 스테이트는 하위 컴포넌트를 랜더링하게 한다.
- 이것을 MVC 패턴으로 보면 상위 컴포넌트의 상태는 Model이며, 이 상위 컴포넌트에 영향을 받는 하위 컴포넌트는 상위 컴포넌트의 모델에 대해 뷰를 생성한다.
- 하나의 컴포넌트에 대해서 상위 컴포넌트는 여러개가 있을 수 있으며 이 여러개는 상위 하위 관계로 구성되어 있다. 
- 이 말은 하나의 컴포넌트의 랜더링은 여러 상위 컴포넌트에 영향을 받는다. 
- MVC 관점에서는 하나의 뷰는 여러 상위 컴포넌트의 모델에 따라 업데이트가 된다. 

#### 뷰는 여러 모델에 영향을 끼침
- 하위 컴포넌트는 상위 컴포넌트로 부터 상위 컴포넌트의 상태를 변경할 수 있는 함수를 전달 받을 수 있다.
- 유저의 조작이나 컴포넌트 내부에 정의한 어떤 상태 변화를 유도하는 무언가에 의해서 상위 컴포넌트에서 전달 받은 상태 변경 메서드를 통해 상위 컴포넌트의 상태를 바꿀 수 있다. 
- 하나의 컴포넌트에 대한 상위 컴포넌트는 여럿이기 때문에 이는 MVC 패턴에 따라 보면 하위 컴포넌트에서 상위 컴포넌트의 상태변경을 유도하는 어떤 이벤트 (자바스크립트의 이벤트가 아닌 개념적인 이벤트)에 의해 상위 컴포넌트의 모델의 데이터를 변경하게 된다. 

### MVC의 문제
#### MVC의 특성
- 여러 모델은 하나의 뷰를 업데이트 시킬 수 있다.
- 뷰는 여러 모델에 영향을 끼칠 수 있다.

#### MVC의 문제 이유
> a 컴포넌트는 A라는 상위 컴포넌트의 하위 컴포넌트이며 A와 a는 여러 개의 컴포넌트 계층으로 구성되어 있다.
> b 컴포넌트는 B라는 상위 컴포넌트의 하위 컴포넌트이며 B와 b는 여러 개의 컴포넌트 계층으로 구성되어 있다.
> A 와 B는 공통의 상위 컴포넌트 S를 가지고 있다.
> a 컴포넌트에는 메시지의 읽지 않은 수를 표시한다.
> b 컴포넌트에는 읽지 않는 메시지를 강조하는 목록을 표시한다. 
> b 컴포넌트의 메시지를 하나 읽게 되면, a 컴포넌트의 카운터가 1 감소해야 한다.
- b는 S의 상태를 변경해야 한다. S의 상태를 변경하게 되면S는 a를 랜더링 시키기 위해서 S와 a사이의 모든 컴포넌트를 랜더링 시킨다.
- 계단식 업데이트
- 종속성
- 데이터 흐름이 뒤엉켜 예측 불가


### 들어가기에 앞서
- 리액트는 컴포넌트가 분기 되기 시작하기 전의 최상위 계층의 컴포넌트에 변수를 저장하여 전역 변수 처럼 사용할 수 있다.

### 디스패처
- action으로 표현된다.
- 리액트의 스테이트를 업데이트 하기 위한 함수이다. 이 함수를 helper methods라고 한다.

### 뷰
- 뷰는 유저에게 보여지는 영역이다. 웹 어플리케이션에서 MVC의 뷰(view)는 화면에 보이는 영역으로 유저 인터페이스를 담당하는 영역이다. 리액트 어플리케이션 한정으로 보면 화면에 랜더링을 담당하는 부분이다.
- 뷰는 리액트의 컴포넌트를 의미하는 것이 아니며 JSX 또는 createElement로 전달받은 데이터가 합쳐져 불변 객체인 React-element로 변환되는 과정을 담당하는 기능 및 React-element가 화면에 랜더링 되는 부분까지를 의미한다. 컴포넌트는 이미 적재되어 있는 상태이며 이 컴포넌트는 자바스크립트에 의해 실행 컨텍스트화 되어 있는 상태이다. 뷰는 실행 컨텍스트 상태에서 React-element를 만들고 랜더링을 하여 화면에 보여주는 역할까지를 의미한다. React-element가 Dom-element가 되는 과정은 정해져 있는 로직을 따르므로 통상적으로 뷰는 React-element를 만드는 과정까지라고 볼 수도 있다.
- 뷰가 스토어로 부터 이벤트를 전달 받으면, 뷰는 스토어에 내장된 getter 메서드를 호출하여 스토어에 저장된 새로운 데이터를 가져온다. 데이터를 가져오게 되면 setState() 또는 forceUpdate() 메서드를 호출 하여 컴포넌트의 render() 메서드와 모든 하위 뷰의 render() 함수를 호출한다. 하위 뷰를 랜더링 하는 방식은 데이터 전달을 통해 리액트 컴포넌트의 갱신 사이클을 돌리는 것이다.
- React flux 패턴에서 뷰는 계층적 컴포넌트에 의해 생성되는 실행 컨텍스트 상에서의 계층적 뷰이며, 뷰 계층의 최상위의 스토어에서 생성된 브로드캐스팅 이벤트를 전달받고 스토어에서 데이터를 얻어 불변 객체인 React-element로 변환된다.
- 스토어의 이벤트를 받은 뷰는 스토어에서 데이터를 가져오고 하위 뷰로 가져온 데이터를 전달 할 수 있다. 이를 체인이라고 한다.


### 컨트롤러
- 뷰와 모델 사이에서 데이터 전달을 컨트롤 하는 부분을 의미한다.
- 리액트에서는 컴포넌트에 저장되어 있는 상태(state)가 setState에 의해 상태 변경 이벤트가 발생하면 변경되는 상태들을 종합해서 상태 변경이 이뤄진 뷰의 render()를 호출함과 동시에 하위 뷰에 상태 데이터를 전달하고 전달된 데이터를 반영하여 하위 뷰들도 render() 함수를 호출한다. 이렇게 저장된 상태를 뷰로 전달하는 매커니즘에 관한 부분을 리액트에서 컨트롤러라고 한다.
- 체인을 통해 상태 데이터가 뷰로 전달되는 부분에서 전달되는 데이터를 가공해서 전달하는 것이 개발자가 리액트에서 다룰 수 있는 컨트롤러의 영역이다.
- flux 패턴에서는 저장소가 뷰 계층의 탑(최상단) 끝점에 있고 여기서 데이터를 뷰로 전달한다. 저장소에서 뷰로 데이터를 전달 할 수 있는 부분이 최상단 뷰이다. '저장소 => 최상단 뷰'로 데이터가 전달되며 이 부분이 컨트롤러의 영역이다. 하위 뷰로 데이터가 전달되는 과정은 뷰의 내부 매커니즘으로 봐야 하므로 컨트롤러라고 할 수 있는 부분이 아주 작다. 그리고 리액트의 flux 패턴에서 이 부분에 대한 컨트롤을 커스텀으로 추가하지 않는다. 

### 컨트롤러-뷰
- 뷰 계층의 하위로 스토어의 전체 상태를 단일 객체로 전달할 필요성이 있다. 
- 컨트롤러란 최상위 계층에서 

### 스토어
- 플럭스 모델에서는 스토어는 모델에 대응한다.
- 웹 어플리케이션의 MVC에서 모델은 데이터베이스 전체 데이터가 아닌 디비의 일부 데이터만 가져와서 데이터를 집어 넣고 수정하고 삭제한다. 이는 모델의 뜻이 데이터를 조회, 삽입, 수정, 삭제하기 위한 어떤 코드, 구조, 기능을 의미하는 것으로 볼 수 있다.
- 웹 어플리케이션의 모델과는 달리 flux 패턴에서의 store는 리액트 어플리케이션의 렌더링에 필요한 모든 상태를 담고 있기 때문에 모델이라기 보다는 스토어라고 부른다. 마치 웹 어플리케이션의 MVC 모델의 데이터베이스처럼 모든 상태데이터를 저장하는 곳이 스토어이다. 하지만 스토어는 특정 도메인에 대한 정보를 저장하는 곳으로 정의된다.
- 저장소라는 뜻은 응용프로그램 내의 특정 도메인의 상태를 저장하는 의미를 가지고 있으며 flux 패턴에서는 리액트로 구성된 프론트앤드 어플리케이션에서 브라우저에서 화면을 랜더링하는 도메인에 대한 상태 데이터를 저장하는 의미를 갖는다.
- 페이스북의 예 : Lookback Video Editor에서 재생 시간에 관한 상태를 저장하는 곳으로 TimeStore라는 저장소를 사용했다. TimeStore를 통해서  재생 시간 위치와 재생 상태를 추적할 수 있다. 이미지 모음에서는 ImageStore라는 저장소를 사용하여 그룹단위로 저장된 이미지를 추적할 수 있다. 이는 재생 시간에 관한 도메인과 이미지에 관한 도메인에 대한 저장소를 각각 구성한 것이다. 또한 TodoMVC예제에서 To do list의 각각의 항목에 대한 상태를 저장하는 곳이 TodoStore로 어플리케이션의 특정 도메인(재생시간, 이미지, 할 일)에 대한 상태를 저장하는 곳이 저장소라는 개념의 핵심이다.
- 스토어는 뷰의 전체 상태를 관리하기 때문에 스토어에서 여러 대상이 되는 뷰로 이벤트를 보내는 과정을 브로드캐스팅이라고 한다. 

### React flux 패턴에서 저장소 구현
- 저장소는 디스패처에 등록이 되며, 디스패처는 저장소를 업데이트 할 수 있는 기능을 정의할 수 있는 콜백을 제공한다. 콜백 함수 내에 저장소를 업데이트 하는 기능을 구현하면 된다.
- 추가적인 내용 필요.

### Flux 패턴의 구성
- 스토어, 디스패처, 뷰

### Flux 패턴에 모델, 컨트롤러가 없는 이유
- 앤터티란 저장소에 저장될 수 있는 어떤 것이다. 모델이라는 것은 전체 상태의 집합에서 일부 앤터티에 대한 앤터티의 상태를 변경하는 매커니즘들의 집합을 의미한다. 그런데 flux 패턴에서는 일부 앤터티에 대한 상태를 변경하게 되면 ... 뷰에 데이터를 전달할 때 일부 엔터티를 가져 오는 것이 아닌 저장소의 모든 상태를 뷰들로 전달하는 방식이기 때문에 일부 엔터티 데이터들을 뷰에 전달하는 역할을 하는 컨트롤러와는 개념이 다르다.???
- Flux 패턴에서는 스토어의 전체 데이터를 객체화 하여 뷰 계층의 탑에서 데이터를 하위 뷰로 체인하여 전달하는 방식이다. 모든 상태를 뷰 전체에 전달하는 방식이기 때문에 ...

### flux update cycle


### 리액트의 특징
- 리액트는 상위 컴포넌트와 하위 컴포넌트의 트리 구조로 구성되어 있으며, 최상단에 하나의 컴포넌트로 부터 하위 컴포넌트를 포함하는 방식으로 구성된다.
- 리액트는 데이터를 각 로컬 스테이트로 관리를 하거나, 상위 컴포넌트의 데이터를 하위 컴포넌트에게 전달하는 방식으로 구성한다. 
- 상위 컴포넌트에 공통적으로 데이터를 저장할 수도 있지만 컴포넌트가 분기 되기 시작하기 전의 최상위 계층의 컴포넌트에 데이터를 항상 저장하는 것이 아닌 상위 컴포넌트에 데이터를 저장하고 공유가 필요한 데이터는 하위 컴포넌트에서 상위 컴포넌트의 상태를 공유하는 방식으로 사용한다.

### 중앙 디스패처 (central dispatcher)
- 리액트 어플리케이션의 모든 데이터를 통합 관리하는 한 단위의 저장소를 중앙 디스패처라고 한다.
- 모든 데이터를 통합관리 하기 위해서는 어플리케이션의 모든 컴포넌트에 상태를 공유 상태를 전달 할 수 있어야 한다.
- 디스패처를 통해 스토어의 상태가 변하면 영향을 받는 모든 컴포넌트는 새로 랜더링(업데이트)을 하게 된다.

